<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic 2D Underwater Hockey Simulator</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            align-items: center;
            min-height: 100vh;
            background-color: #f0f8ff; /* Lighter background */
            padding: 10px;
            box-sizing: border-box;
        }
        #gameContainer { /* Wrap canvas and info */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px; /* Max width for very large screens */
            margin-bottom: 10px;
        }
        canvas {
            background-color: #00008B;
            border: 2px solid #000;
            width: 100%; /* Make canvas fill container width */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 2 / 1; /* Maintain 2:1 aspect ratio */
            display: block; /* Remove extra space below canvas */
        }
        .gameInfo {
            display: flex; /* Arrange info horizontally */
            justify-content: space-around; /* Space out info items */
            width: 100%;
            color: #333; /* Darker text for light background */
            font-family: Arial, sans-serif;
            background-color: rgba(200, 200, 200, 0.7);
            padding: 8px;
            border-radius: 3px;
            margin-bottom: 5px; /* Space between info and button */
            box-sizing: border-box;
        }
        .gameInfo div { margin: 0 5px; } /* Spacing for info items */
        #controls { /* Container for buttons */
             width: 100%;
             display: flex;
             justify-content: center;
             margin-bottom: 10px;
        }
        #aiStateToggle { /* Keep button styling simple */
             padding: 5px 10px;
        }
        #playerInfoTableContainer {
            width: 100%;
            max-width: 1200px; /* Match canvas max width */
            max-height: 250px; /* Slightly more height */
            overflow: auto; /* Enable scrolling */
            background-color: rgba(0,0,0,0.7);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 11px; /* Slightly smaller font */
            border-radius: 3px;
            padding: 5px;
            box-sizing: border-box;
        }
         #playerInfoTable {
             width: 100%;
             border-collapse: collapse;
             white-space: nowrap; /* Prevent text wrapping */
         }
         #playerInfoTable th, #playerInfoTable td {
             border-bottom: 1px solid rgba(255, 255, 255, 0.3);
             padding: 3px 5px;
             text-align: left;
         }
         #playerInfoTable th {
             background-color: rgba(255, 255, 255, 0.1);
             position: sticky; /* Keep headers visible on scroll */
             top: 0;
         }
         #playerInfoTable td:nth-child(n+4) { /* Right-align numerical columns */
            text-align: right;
         }

    </style>
</head>
<body>
    <!-- Structure Changes: Wrap canvas/info, add controls div -->
    <div id="gameContainer">
        <div class="gameInfo">
            <div>Time: <span id="gameTime">--:--</span></div>
            <div>Score: Black <span id="blackScore">0</span> - <span id="whiteScore">0</span> White</div>
            <div>Half: <span id="currentHalf">1</span></div>
            <div>State: <span id="gameStateDisplay">PreKickoff</span></div> <!-- Added Game State -->
        </div>
         <div id="controls">
            <button id="aiStateToggle">Toggle AI State View</button>
            <!-- Add more controls here if needed -->
         </div>
        <canvas id="gameCanvas"></canvas> <!-- Width/Height set by JS -->
    </div>

    <div id="playerInfoTableContainer">
        <table id="playerInfoTable">
            <thead>
                <tr>
                    <!-- Added More Headers -->
                    <th>Team</th>
                    <th>Role</th>
                    <th>State</th>
                    <th>X</th>
                    <th>Y</th>
                    <th>dX</th>
                    <th>dY</th>
                    <th>Breath(s)</th>
                    <th>Stamina</th>
                    <th>TargetX</th>
                    <th>TargetY</th>
                    <th>Puck?</th>
                    <th>Surface?</th>
                </tr>
            </thead>
            <tbody id="playerInfoTableBody">
                <!-- Player data will be inserted here by JavaScript -->
            </tbody>
        </table>
    </div>

    <script>
        // --- Configuration ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Make Field dimensions variable
        let FIELD_WIDTH = 1000; // Default/Initial
        let FIELD_HEIGHT = 500; // Default/Initial
        let GOAL_WIDTH = FIELD_WIDTH * 0.3;
        const GOAL_DEPTH = 15;
        const PUCK_RADIUS = 8;
        const PLAYER_RADIUS = 12;
        const STICK_LENGTH = 20;
        const STICK_WIDTH = 4;
        const BASE_PLAYER_SPEED = 1.8; // Base speed in units per frame
        // Adjust speeds based on typical screen size? Or keep absolute for now.
        const PUCK_FRICTION = 0.985;
        const PUCK_MAX_SPEED = 15;
        const PUSH_FORCE = 0.5;
        const FLICK_FORCE = 8;
        const TACKLE_RANGE = PLAYER_RADIUS + PUCK_RADIUS + 5;
        const BASE_BREATH_TIME_SECONDS = 15; // Base breath time in seconds
        const STAMINA_MAX = 100;
        const STAMINA_DRAIN = 0.1;
        const STAMINA_RECOVERY = 0.05;
        const BREATH_RECOVERY_RATE_PER_SEC = 3; // Breath units recovered per second on surface
        const GAME_HALF_TIME_SECONDS = 5 * 60;
        const FRAMES_PER_SECOND = 60; // Target FPS
        const FORMATION_LINE_SPACING = 40; // Approx 2 meters if field width is ~25m (adjust as needed)
        const PUCK_INFLUENCE_ON_LINES = 0.5; // How much puck position shifts the lines (0 to 1)

        // Calculated constants based on FPS
        let BASE_BREATH_TIME = BASE_BREATH_TIME_SECONDS * FRAMES_PER_SECOND;
        let BREATH_RECOVERY_RATE = BREATH_RECOVERY_RATE_PER_SEC * (1 / FRAMES_PER_SECOND); // Breath units per frame

        // --- Game State ---
        let puck = { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2, dx: 0, dy: 0 };
        let teams = { black: [], white: [] };
        let scores = { black: 0, white: 0 };
        let gameTimer = GAME_HALF_TIME_SECONDS * FRAMES_PER_SECOND;
        let currentHalf = 1;
        let gamePaused = true;
        let showAiState = true;
        let lastTimestamp = 0;
        let gameState = 'PreKickoff';


        // --- Resize Handling ---
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            // Maintain 2:1 aspect ratio
            const newWidth = containerWidth;
            const newHeight = containerWidth / 2;

            // Update canvas element size
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Update simulation dimensions
            FIELD_WIDTH = newWidth;
            FIELD_HEIGHT = newHeight;
            GOAL_WIDTH = FIELD_WIDTH * 0.3; // Recalculate goal width

            // Optional: Rescale or reposition elements if needed
            // For simplicity, we'll let elements adjust based on new FIELD_WIDTH/HEIGHT
            // but a full rescale might involve adjusting speeds, radii etc.
            // If positions go out of bounds, they should be clamped in update loops.
            // Reset puck/players if resize is drastic? Or let them adapt.
             resetPuck(); // Reset puck to center on resize
             // Consider if player positions need adjusting or if clamping is enough
             console.log(`Resized to ${FIELD_WIDTH}x${FIELD_HEIGHT}`);
        }

        // --- Initialization ---
        function initPlayers() {
            teams.black = [];
            teams.white = [];
            const roles = ['Forward', 'Forward', 'Mid', 'Mid', 'Back', 'Back'];
            const startYIncrement = FIELD_HEIGHT / 7; // Use current FIELD_HEIGHT

            for (let i = 0; i < 6; i++) {
                const yPos = startYIncrement * (i + 1);
                const blackStartX = PLAYER_RADIUS + 5;
                const whiteStartX = FIELD_WIDTH - PLAYER_RADIUS - 5; // Use current FIELD_WIDTH
                // Recalculate BASE_BREATH_TIME for each player based on current FPS setting
                BASE_BREATH_TIME = BASE_BREATH_TIME_SECONDS * FRAMES_PER_SECOND;
                teams.black.push(createPlayer(blackStartX, yPos, 'black', roles[i]));
                teams.white.push(createPlayer(whiteStartX, yPos, 'white', roles[i]));
            }
        }

        function createPlayer(x, y, color, role) {
             // Recalculate BASE_BREATH_TIME here too for safety
             BASE_BREATH_TIME = BASE_BREATH_TIME_SECONDS * FRAMES_PER_SECOND;
             const maxBreath = BASE_BREATH_TIME * (0.8 + Math.random() * 0.4);
             return {
                 x, y, color, role,
                 dx: 0, dy: 0,
                 angle: color === 'black' ? 0 : Math.PI,
                 speed: BASE_PLAYER_SPEED * (0.9 + Math.random() * 0.2),
                 breath: maxBreath,
                 maxBreath: maxBreath,
                 stamina: STAMINA_MAX,
                 state: 'PreKickoff',
                 isOnSurface: true,
                 hasPuck: false,
                 targetX: x,
                 targetY: y,
                 lastActionTime: 0
             };
        }

        function resetPuck() {
            puck.x = FIELD_WIDTH / 2; // Use current FIELD_WIDTH
            puck.y = FIELD_HEIGHT / 2; // Use current FIELD_HEIGHT
            puck.dx = 0;
            puck.dy = 0;
        }

        function resetPositionsForKickoff() {
            resetPuck();
            initPlayers(); // Re-initializes players based on current dimensions
            teams.black.forEach(p => {
                p.angle = 0;
                p.state = 'PreKickoff';
                p.isOnSurface = true;
                p.breath = p.maxBreath;
                p.stamina = STAMINA_MAX;
                p.targetX = p.x;
                p.targetY = p.y;
            });
            teams.white.forEach(p => {
                p.angle = Math.PI;
                p.state = 'PreKickoff';
                p.isOnSurface = true;
                p.breath = p.maxBreath;
                p.stamina = STAMINA_MAX;
                p.targetX = p.x;
                p.targetY = p.y;
            });
            gamePaused = false;
            gameState = 'Kickoff';
            console.log("Kickoff!");
        }

        // --- Helper Function for Drawing (Moved Earlier) ---
        function calculateDynamicLineX(baseRole, teamColor, possessingTeam) {
            // Only calculate if it's the possessing team's line
            if (teamColor !== possessingTeam) {
                return null; // Don't calculate/draw for non-possessing team
            }

            // Find the puck carrier on the possessing team (if any)
            let puckCarrier = null;
            if (possessingTeam) {
                puckCarrier = teams[possessingTeam].find(p => p.hasPuck);
            }

            // Calculate a center point influenced by the puck's position
            const centerBias = (puck.x - FIELD_WIDTH / 2) * PUCK_INFLUENCE_ON_LINES;
            let dynamicCenter = FIELD_WIDTH / 2 + centerBias;

            // Stronger influence if a teammate has the puck
            let carrierInfluence = 0;
            if (puckCarrier) {
                // If the carrier's role matches the line role, pull the line strongly
                if (puckCarrier.role.includes(baseRole)) {
                     carrierInfluence = (puckCarrier.x - dynamicCenter) * 0.8; // Strong pull
                } else {
                     carrierInfluence = (puckCarrier.x - dynamicCenter) * 0.3; // Weaker pull for other lines
                }
                dynamicCenter += carrierInfluence;
            }


            let lineX;
            const spacing = FORMATION_LINE_SPACING; // Approx 2m

            // Determine line position relative to dynamic center
            if (teamColor === 'black') { // Attacking right
                if (baseRole === 'Forward') lineX = dynamicCenter + spacing;
                else if (baseRole === 'Back') lineX = dynamicCenter - spacing;
                else lineX = dynamicCenter;
            } else { // White, attacking left
                if (baseRole === 'Forward') lineX = dynamicCenter - spacing;
                else if (baseRole === 'Back') lineX = dynamicCenter + spacing;
                else lineX = dynamicCenter;
            }

            // Clamp line position, allowing Forward line to reach goal area
            const buffer = PLAYER_RADIUS; // Reduced buffer
            const goalBuffer = GOAL_DEPTH + PLAYER_RADIUS;
            if (baseRole === 'Forward') {
                 // Allow forward line to go almost into the goal
                 lineX = Math.max(goalBuffer, Math.min(FIELD_WIDTH - goalBuffer, lineX));
            } else {
                 // Keep Mid/Back lines further out
                 lineX = Math.max(buffer * 3, Math.min(FIELD_WIDTH - buffer * 3, lineX));
            }

            return lineX;
        }

        function getPuckPossessorTeam() {
            for (const player of teams.black) {
                if (player.hasPuck) return 'black';
            }
            for (const player of teams.white) {
                if (player.hasPuck) return 'white';
            }
            return null; // Puck is loose
        }

        // --- Drawing ---
        function drawField() {
            // Pool bottom
            ctx.fillStyle = '#00008B';
            ctx.fillRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);

            // Goals
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(0, (FIELD_HEIGHT - GOAL_WIDTH) / 2, GOAL_DEPTH, GOAL_WIDTH);
            ctx.fillRect(FIELD_WIDTH - GOAL_DEPTH, (FIELD_HEIGHT - GOAL_WIDTH) / 2, GOAL_DEPTH, GOAL_WIDTH);

            // --- Draw Dynamic Formation Lines ---
            const possessingTeam = getPuckPossessorTeam(); // Check who has the puck

            // Keep track of the last known positions of the lines
            if (!window.lastLeftLineY) window.lastLeftLineY = FIELD_HEIGHT / 4;
            if (!window.lastRightLineY) window.lastRightLineY = (FIELD_HEIGHT * 3) / 4;

            if (possessingTeam) {
                // Adjust the horizontal lines based on puck position
                const puckOnLeft = puck.x < FIELD_WIDTH / 2; // Determine if puck is on the left side
                window.lastLeftLineY = puckOnLeft ? puck.y : puck.y - FORMATION_LINE_SPACING;
                window.lastRightLineY = window.lastLeftLineY + FORMATION_LINE_SPACING;
            }

            ctx.save();
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';

            const teamColorStyle = possessingTeam === 'black' ? 'rgba(200, 200, 200, 0.7)' : 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = teamColorStyle;
            ctx.fillStyle = teamColorStyle;

            // Vertical F/M/B Lines
            ['Forward', 'Mid', 'Back'].forEach(role => {
                const lineX = calculateDynamicLineX(role, possessingTeam, possessingTeam);
                if (lineX !== null) {
                    ctx.beginPath();
                    ctx.moveTo(lineX, 0);
                    ctx.lineTo(lineX, FIELD_HEIGHT);
                    ctx.stroke();
                    // Add Label (F, M, B)
                    const label = role.substring(0, 1);
                    ctx.fillText(label, lineX, 10); // Label near top edge
                }
            });

            // --- Horizontal Left/Right Lines ---
            const leftLineY = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, window.lastLeftLineY));
            const rightLineY = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, window.lastRightLineY));

            // Draw Left Line
            ctx.beginPath();
            ctx.moveTo(0, leftLineY);
            ctx.lineTo(FIELD_WIDTH, leftLineY);
            ctx.stroke();
            ctx.fillText('L', 10, leftLineY - 5); // Label near left edge

            // Draw Right Line
            ctx.beginPath();
            ctx.moveTo(0, rightLineY);
            ctx.lineTo(FIELD_WIDTH, rightLineY);
            ctx.stroke();
            ctx.fillText('R', 10, rightLineY + 15); // Label near left edge

            ctx.restore();
        }

        function drawPuck() {
            ctx.fillStyle = '#FF4500'; // Orangey-red puck
            ctx.beginPath();
            ctx.arc(puck.x, puck.y, PUCK_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            // Add a white dot for visual spin/orientation (optional)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(puck.x + PUCK_RADIUS * 0.6 * Math.cos(puck.dx), puck.y + PUCK_RADIUS * 0.6 * Math.sin(puck.dy), 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayers() {
            [...teams.black, ...teams.white].forEach(player => {
                ctx.save(); // Save current context state

                // Set alpha based on state (Surfacing or OnSurface)
                if (player.state === 'Surfacing' || player.isOnSurface) {
                     // Use slightly different alpha for surfacing vs waiting on surface?
                    ctx.globalAlpha = player.state === 'Surfacing' ? 0.3 : 0.5; // Example: Surfacing=fainter
                } else {
                    ctx.globalAlpha = 1.0; // Fully opaque otherwise
                }

                // Player body
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x, player.y, PLAYER_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'grey'; // Outline
                ctx.stroke();

                // Stick (only draw if not surfacing/on surface)
                if (player.state !== 'Surfacing' && !player.isOnSurface) {
                    const stickEndX = player.x + STICK_LENGTH * Math.cos(player.angle);
                    const stickEndY = player.y + STICK_LENGTH * Math.sin(player.angle);
                    ctx.strokeStyle = player.color === 'black' ? 'lightblue' : 'darkgrey';
                    ctx.lineWidth = STICK_WIDTH;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(stickEndX, stickEndY);
                    ctx.stroke();
                    ctx.lineWidth = 1; // Reset line width
                }

                 // Restore alpha and other context settings
                ctx.restore();

                // --- Indicators drawn with full opacity regardless of player state ---
                const breathRatio = player.breath / player.maxBreath;
                ctx.fillStyle = breathRatio > 0.3 ? 'lightgreen' : 'orange';
                if (player.state === 'Surfacing' || (player.isOnSurface && breathRatio < 1)) ctx.fillStyle = 'lightblue'; // Indicate recovering on surface
                if (player.breath <= 0 && player.state !== 'Surfacing') ctx.fillStyle = 'red'; // Show red if forced to surface soon
                ctx.fillRect(player.x - PLAYER_RADIUS, player.y - PLAYER_RADIUS - 8, PLAYER_RADIUS * 2 * breathRatio, 4);

                const staminaRatio = player.stamina / STAMINA_MAX;
                ctx.fillStyle = 'yellow';
                ctx.fillRect(player.x - PLAYER_RADIUS, player.y - PLAYER_RADIUS - 14, PLAYER_RADIUS * 2 * staminaRatio, 3);

                if (showAiState) {
                    ctx.fillStyle = (player.state === 'Surfacing' || player.isOnSurface) ? 'rgba(255, 255, 255, 0.6)' : 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    let stateText = player.isOnSurface ? 'Surface' : player.state;
                    if (player.state === 'Surfacing') stateText = 'SURF'; // Override if actively surfacing
                    const rolePrefix = player.role.substring(0,1);
                    ctx.fillText(`${rolePrefix}:${stateText.substring(0,4)}`, player.x, player.y + PLAYER_RADIUS + 10);
                    ctx.textAlign = 'start';
                }
            });
        }

        // --- Physics & Collision ---
        function updatePuck() {
            if (gamePaused) return;

            // Apply friction
            puck.dx *= PUCK_FRICTION;
            puck.dy *= PUCK_FRICTION;

            // Limit speed
            const speed = Math.sqrt(puck.dx * puck.dx + puck.dy * puck.dy);
            if (speed > PUCK_MAX_SPEED) {
                puck.dx = (puck.dx / speed) * PUCK_MAX_SPEED;
                puck.dy = (puck.dy / speed) * PUCK_MAX_SPEED;
            }
            if (Math.abs(speed) < 0.1) { // Stop if very slow
                 puck.dx = 0;
                 puck.dy = 0;
            }


            // Move puck
            puck.x += puck.dx;
            puck.y += puck.dy;

            // Wall collisions
            if (puck.x - PUCK_RADIUS < 0) { puck.x = PUCK_RADIUS; puck.dx *= -0.8; }
            if (puck.x + PUCK_RADIUS > FIELD_WIDTH) { puck.x = FIELD_WIDTH - PUCK_RADIUS; puck.dx *= -0.8; }
            if (puck.y - PUCK_RADIUS < 0) { puck.y = PUCK_RADIUS; puck.dy *= -0.8; }
            if (puck.y + PUCK_RADIUS > FIELD_HEIGHT) { puck.y = FIELD_HEIGHT - PUCK_RADIUS; puck.dy *= -0.8; }

            checkGoal();
        }

        function updatePlayers(framesElapsed) { // Accept framesElapsed
             if (gamePaused && gameState !== 'Kickoff') return;
             const allPlayers = [...teams.black, ...teams.white];

             allPlayers.forEach(player => {
                let isUnderwater = !player.isOnSurface && player.state !== 'Surfacing';

                // --- Breath & Stamina ---
                if (isUnderwater) {
                    player.breath -= framesElapsed; // Use framesElapsed for drain
                    if (player.breath <= 0) {
                        // Heuristic: Low Breath Action (Puck Possession)
                        if (player.hasPuck) {
                            const opponentGoalX = player.color === 'black' ? FIELD_WIDTH : 0;
                            const goalY = FIELD_HEIGHT / 2;
                            const angleToGoal = Math.atan2(goalY - player.y, opponentGoalX - player.x);
                            puck.dx += Math.cos(angleToGoal) * PUSH_FORCE * 2;
                            puck.dy += Math.sin(angleToGoal) * PUSH_FORCE * 2;
                            player.hasPuck = false;
                        }
                        player.state = 'Surfacing';
                        player.breath = 0;
                    }
                    // Drain stamina based on speed
                    const currentSpeed = Math.sqrt(player.dx * player.dx + player.dy * player.dy);
                    if (currentSpeed > player.speed * 0.5) player.stamina -= STAMINA_DRAIN * framesElapsed; // Scale drain by frames
                    else player.stamina += STAMINA_RECOVERY * framesElapsed; // Scale recovery by frames
                    player.stamina = Math.max(0, Math.min(STAMINA_MAX, player.stamina));

                } else { // Recovering breath (Surfacing or OnSurface)
                    // *** Use framesElapsed for recovery ***
                    player.breath += BREATH_RECOVERY_RATE_PER_SEC * (FRAMES_PER_SECOND / 1000) * (framesElapsed * (1000 / FRAMES_PER_SECOND)); // Recover based on seconds elapsed
                    // Simplified: player.breath += BREATH_RECOVERY_RATE_PER_SEC * framesElapsed / FRAMES_PER_SECOND; // Breath units per second * seconds elapsed
                    // Let's use the direct rate per frame calculation adjusted by elapsed frames
                    player.breath += BREATH_RECOVERY_RATE * framesElapsed;


                    if (player.breath >= player.maxBreath) {
                        player.breath = player.maxBreath;
                        if (player.state === 'Surfacing') {
                            player.state = 'OnSurface'; // Transition to waiting on surface
                            player.isOnSurface = true; // Ensure flag is set AFTER state change potentially
                        }
                        // Ensure isOnSurface is true if breath is full, even if state wasn't Surfacing
                        player.isOnSurface = true;
                    }
                    // Stamina recovers faster on surface/surfacing
                    player.stamina += STAMINA_RECOVERY * 1.5 * framesElapsed; // Scale recovery by frames
                    player.stamina = Math.max(0, Math.min(STAMINA_MAX, player.stamina));
                }

                // --- AI Decision Making ---
                updateAI(player); // AI sets state, targetX, targetY

                // --- Movement ---
                let isMoving = false;
                let effectiveSpeed = 0;

                // Determine if player should be moving based on state
                // Allow movement during Surfacing, SurfaceMove, KickoffFollow, and all underwater states except Shooting/Idle
                if (player.state !== 'Shooting' && player.state !== 'Idle' && player.state !== 'PreKickoff') {
                     // Can move if underwater OR specifically moving on surface/surfacing/kickoff following
                     if (isUnderwater || player.state === 'SurfaceMove' || player.state === 'KickoffFollow' || player.state === 'Surfacing') {
                         isMoving = true;
                     }
                }

                if (isMoving) {
                    const targetAngle = Math.atan2(player.targetY - player.y, player.targetX - player.x);
                    // Smooth turning (except for shooting)
                    if (player.state !== 'Shooting') {
                        let angleDiff = targetAngle - player.angle;
                        while (angleDiff <= -Math.PI) angleDiff += 2 * Math.PI;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        player.angle += angleDiff * 0.1;
                    } else {
                         player.angle = targetAngle; // Snap angle for shooting
                    }

                    const distanceToTarget = distance(player.x, player.y, player.targetX, player.targetY);
                    let currentSpeedFactor = (0.5 + 0.5 * (player.stamina / STAMINA_MAX));

                    // Adjust speed based on state
                    if (player.state === 'Positioning' || player.state === 'SurfaceMove' || player.state === 'KickoffFollow' || player.state === 'Surfacing') {
                        currentSpeedFactor *= 0.4; // Slower positioning/surface/surfacing movement
                    } else if (player.state === 'KickoffDive') {
                         currentSpeedFactor *= 1.1;
                    }

                    effectiveSpeed = player.speed * currentSpeedFactor;

                    // Reduce speed near target
                    if (distanceToTarget < PLAYER_RADIUS * 2) {
                        effectiveSpeed *= Math.max(0.1, distanceToTarget / (PLAYER_RADIUS * 2)); // Ensure minimum speed if close
                    }

                    if (distanceToTarget > PLAYER_RADIUS * 0.5) {
                        player.dx = Math.cos(player.angle) * effectiveSpeed;
                        player.dy = Math.sin(player.angle) * effectiveSpeed;
                    } else {
                        player.dx = 0;
                        player.dy = 0;
                        isMoving = false; // Stop if close enough
                    }

                    player.x += player.dx;
                    player.y += player.dy;

                    player.x = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, player.x));
                    player.y = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, player.y));

                    // Player-Puck Interaction only if underwater
                    if (isUnderwater) {
                        handlePlayerPuckInteraction(player);
                    }

                } else {
                     // Ensure dx/dy remain 0 if not supposed to be moving
                     player.dx = 0;
                     player.dy = 0;
                }
             });

             handlePlayerCollisions(allPlayers);

             // Check if kickoff phase is over
             if (gameState === 'Kickoff') {
                 const puckDistFromCenterSq = Math.pow(puck.x - FIELD_WIDTH / 2, 2) + Math.pow(puck.y - FIELD_HEIGHT / 2, 2);
                 // Check if puck moved OR enough time passed (e.g., 2 seconds)
                 const kickoffTimeElapsed = (performance.now() - lastTimestamp) / 1000; // Requires lastTimestamp to be set at kickoff start
                 if (puckDistFromCenterSq > Math.pow(PUCK_RADIUS * 5, 2) /* || kickoffTimeElapsed > 2 */) {
                     gameState = 'Playing';
                     console.log("Play starts!");
                     // Ensure players transition out of kickoff states
                     allPlayers.forEach(p => {
                         if (p.state.startsWith('Kickoff')) {
                             p.state = p.isOnSurface ? 'OnSurface' : 'Positioning';
                         }
                     });
                 }
             }
        }

        function handlePlayerPuckInteraction(player) {
            if (player.state === 'Surfacing' || player.isOnSurface) return; // Cannot interact from surface

            const stickTipX = player.x + STICK_LENGTH * Math.cos(player.angle);
            const stickTipY = player.y + STICK_LENGTH * Math.sin(player.angle);
            const dxPuck = puck.x - stickTipX;
            const dyPuck = puck.y - stickTipY;
            const distPuckStick = Math.sqrt(dxPuck * dxPuck + dyPuck * dyPuck);

            player.hasPuck = false; // Reset possession flag

            if (distPuckStick < PUCK_RADIUS + STICK_WIDTH) { // Stick is touching puck
                player.hasPuck = true;
                const pushAngle = player.angle;

                // Apply force based on state
                let force = PUSH_FORCE;
                // *** CRITICAL: Use 'Shooting' state for flick force ***
                if (player.state === 'Shooting') {
                    force = FLICK_FORCE;
                    // Optional: Add cooldown logic here if needed later
                    // player.lastActionTime = performance.now(); // Use performance.now() if using cooldown
                    // Don't change state immediately after shooting, let AI decide next frame
                }

                // Apply force considering player's momentum slightly
                const forceX = Math.cos(pushAngle) * force + player.dx * 0.1;
                const forceY = Math.sin(pushAngle) * force + player.dy * 0.1;

                puck.dx += forceX;
                puck.dy += forceY;

                // Simple curl effect
                 if (player.state === 'Curling') {
                     const angleToPlayer = Math.atan2(player.y - puck.y, player.x - puck.x);
                     puck.dx += Math.cos(angleToPlayer) * 0.1;
                     puck.dy += Math.sin(angleToPlayer) * 0.1;
                 }
            }
        }

        function handlePlayerCollisions(players) {
            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    const p1 = players[i];
                    const p2 = players[j];

                    // Skip collision check if players are at different depths
                    const p1IsAtSurfaceLevel = p1.isOnSurface || p1.state === 'Surfacing';
                    const p2IsAtSurfaceLevel = p2.isOnSurface || p2.state === 'Surfacing';
                    if (p1IsAtSurfaceLevel !== p2IsAtSurfaceLevel) {
                        continue;
                    }

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = PLAYER_RADIUS * 2;

                    if (distance < minDist && distance > 0) {
                        const overlap = minDist - distance;
                        const baseAdjustFactor = 0.4;
                        const separationX = (dx / distance) * overlap;
                        const separationY = (dy / distance) * overlap;

                        if (p1.color === p2.color) { // Teammate collision
                            let p1AdjustFactor = baseAdjustFactor;
                            let p2AdjustFactor = baseAdjustFactor;
                            let p1TargetReset = false;
                            let p2TargetReset = false;

                            // *** Increase push-back force for non-carrier ***
                            const pushBackFactor = 1.5; // Increased from 1.0

                            if (p1.hasPuck && !p2.hasPuck) {
                                p2AdjustFactor = pushBackFactor; // Push p2 away more forcefully
                                p1AdjustFactor = 0.1;
                                p2TargetReset = true;
                            } else if (p2.hasPuck && !p1.hasPuck) {
                                p1AdjustFactor = pushBackFactor; // Push p1 away more forcefully
                                p2AdjustFactor = 0.1;
                                p1TargetReset = true;
                            }

                            p1.x -= separationX * p1AdjustFactor;
                            p1.y -= separationY * p1AdjustFactor;
                            p2.x += separationX * p2AdjustFactor;
                            p2.y += separationY * p2AdjustFactor;

                            if (p1TargetReset && p1.state !== 'Surfacing') {
                                p1.state = 'Positioning'; // Force repositioning
                            }
                            if (p2TargetReset && p2.state !== 'Surfacing') {
                                p2.state = 'Positioning'; // Force repositioning
                            }

                        } else { // Opponent collision
                            p1.x -= separationX * baseAdjustFactor;
                            p1.y -= separationY * baseAdjustFactor;
                            p2.x += separationX * baseAdjustFactor;
                            p2.y += separationY * baseAdjustFactor;
                        }

                        // Clamp positions
                        p1.x = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, p1.x));
                        p1.y = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, p1.y));
                        p2.x = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, p2.x));
                        p2.y = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, p2.y));
                    }
                }
            }
        }


        // --- AI Logic ---
        function updateAI(player) {
            // --- Global Game State Handling ---
            if (gameState === 'Kickoff') {
                handleKickoffAI(player);
                return; // Don't process normal AI during kickoff
            }
            if (gameState !== 'Playing') { // Includes PreKickoff, GoalScored, HalfTime, FullTime
                player.targetX = player.x; // Stay still
                player.targetY = player.y;
                player.dx = 0;
                player.dy = 0;
                if (player.state !== 'PreKickoff') player.state = 'Idle'; // Or appropriate state
                return;
            }

            // --- Breath Management & Surfacing Check ---
            // If surfacing, calculate a reposition target but DO NOT proceed to other AI logic
            if (player.state === 'Surfacing') {
                // Allow AI to set a target for slow repositioning during surfacing
                // Example: Move slowly towards formation position even while surfacing
                const formationPos = calculateFormationPosition(player, true); // Treat as surface for positioning
                player.targetX = formationPos.x;
                player.targetY = formationPos.y;
                // Crucially, still return to prevent underwater/surface logic execution
                return; // Surfacing players only reposition slowly, no other AI decisions this frame
            }

            // --- Surface Behavior ---
            // Use 'else if' because Surfacing is handled above and returns
            else if (player.isOnSurface) {
                handleSurfaceAI(player);
                return; // AI logic specific to being on the surface (diving check)
            }

            // --- Underwater Behavior ---
            // Only executed if not Surfacing and not OnSurface
            else {
                 handleUnderwaterAI(player);
            }
        }

        function handleKickoffAI(player) {
            // Heuristics: Forwards dive, Backs/Mids follow on surface
            if (player.role === 'Forward') {
                if (player.state !== 'KickoffDive') { // Only set state once
                    player.state = 'KickoffDive';
                    player.isOnSurface = false; // Dive immediately
                }
                player.targetX = FIELD_WIDTH / 2; // Race to center puck
                player.targetY = FIELD_HEIGHT / 2;
                player.angle = Math.atan2(player.targetY - player.y, player.targetX - player.x);
            } else { // Backs and Mids follow on surface
                 if (player.state !== 'KickoffFollow') {
                     player.state = 'KickoffFollow'; // New state for following
                     player.isOnSurface = true; // Stay on surface
                 }
                 // Target a position slightly ahead of the wall, following the general direction
                 const followX = player.color === 'black' ? FIELD_WIDTH * 0.25 : FIELD_WIDTH * 0.75;
                 // Try to stay in lane vertically, adjust based on puck Y slightly?
                 const followY = player.y + (puck.y - player.y) * 0.1;
                 player.targetX = followX;
                 player.targetY = followY; // Stay in lane initially
                 player.angle = player.color === 'black' ? 0 : Math.PI; // Face forward
            }
        }

        function handleSurfaceAI(player) {
            // Heuristic: Recover breath, move slowly to formation position, check dive conditions
            if (player.state !== 'SurfaceMove') {
                 player.state = 'SurfaceMove'; // Ensure state is correct
            }

            const formationPos = calculateFormationPosition(player, true); // isSurface=true
            player.targetX = formationPos.x;
            player.targetY = formationPos.y;
            // Angle towards target position while moving on surface
            player.angle = Math.atan2(player.targetY - player.y, player.targetX - player.x);


            // Heuristic: Check dive conditions (only if breath is full)
            if (player.breath >= player.maxBreath) {
                const diveDecision = shouldDive(player);
                if (diveDecision) {
                    player.isOnSurface = false;
                    // Determine initial underwater state based on dive reason (more advanced)
                    // Simple: just go towards puck initially after diving
                    player.state = 'ChaseLooseOff'; // Example starting state after dive
                    player.targetX = puck.x;
                    player.targetY = puck.y;
                    console.log(`${player.color} ${player.role} diving! Target Puck.`);
                }
            }
        }

        function handleUnderwaterAI(player) {
            const opponentGoalX = player.color === 'black' ? FIELD_WIDTH : 0;
            const ownGoalX = player.color === 'black' ? 0 : FIELD_WIDTH;
            const goalY = FIELD_HEIGHT / 2;

            const puckDist = distance(player.x, player.y, puck.x, puck.y);
            const puckDistToOwnGoal = distance(puck.x, puck.y, ownGoalX, goalY);
            const puckDistToOpponentGoal = distance(puck.x, puck.y, opponentGoalX, goalY);

            const nearestOpponent = findNearestOpponent(player);
            const nearestOpponentDist = nearestOpponent ? distance(player.x, player.y, nearestOpponent.x, nearestOpponent.y) : Infinity;

            // --- Determine Current Puck Possession ---
            // Check self first
            const iHavePuck = player.hasPuck; // Use the flag updated by handlePlayerPuckInteraction

            // Check opponents
            const opponentTeam = player.color === 'black' ? teams.white : teams.black;
            let opponentHasPuck = false;
            let puckCarrierOpponent = null;
            for (const opp of opponentTeam) {
                 // Check if opponent is close AND their stick is likely touching puck
                 if (!opp.isOnSurface && distance(opp.x, opp.y, puck.x, puck.y) < PLAYER_RADIUS + PUCK_RADIUS + 5) {
                     const oppStickTipX = opp.x + STICK_LENGTH * Math.cos(opp.angle);
                     const oppStickTipY = opp.y + STICK_LENGTH * Math.sin(opp.angle);
                     if (distance(oppStickTipX, oppStickTipY, puck.x, puck.y) < PUCK_RADIUS + STICK_WIDTH + 2) { // Slightly tighter check
                         opponentHasPuck = true;
                         puckCarrierOpponent = opp;
                         break;
                     }
                 }
            }

            // Check teammates (only if self and opponent don't have it)
            let teammateHasPuck = false;
            let puckCarrierTeammate = null;
            if (!iHavePuck && !opponentHasPuck) {
                const teammates = teams[player.color].filter(p => p !== player && !p.isOnSurface);
                const supportRange = FIELD_WIDTH * 0.25; // Increased range slightly
                for (const tm of teammates) {
                     // Check if teammate is close AND their stick is likely touching puck
                     if (distance(player.x, player.y, tm.x, tm.y) < supportRange && distance(tm.x, tm.y, puck.x, puck.y) < PLAYER_RADIUS + PUCK_RADIUS + 5) {
                         const tmStickTipX = tm.x + STICK_LENGTH * Math.cos(tm.angle);
                         const tmStickTipY = tm.y + STICK_LENGTH * Math.sin(tm.angle);
                         if (distance(tmStickTipX, tmStickTipY, puck.x, puck.y) < PUCK_RADIUS + STICK_WIDTH + 2) { // Slightly tighter check
                            // Verify teammate's own hasPuck flag for consistency? Optional.
                            // if (tm.hasPuck) {
                                teammateHasPuck = true;
                                puckCarrierTeammate = tm;
                                break;
                            // }
                         }
                     }
                }
            }
            // If no one clearly has it based on stick proximity, it's loose
            const puckIsLoose = !iHavePuck && !opponentHasPuck && !teammateHasPuck;

            // --- State Transitions (Prioritized) ---
            let desiredState = player.state; // Start with current state

            if (iHavePuck) {
                // Player has the puck: Offensive states
                const isNearOppGoal = puckDistToOpponentGoal < FIELD_WIDTH * 0.3;
                const isDangerouslyNearOwnGoal = puckDistToOwnGoal < FIELD_WIDTH * 0.20;
                if (isNearOppGoal) desiredState = 'Shooting';
                else if (isDangerouslyNearOwnGoal) desiredState = 'Clearing';
                else desiredState = 'Curling';

            } else if (opponentHasPuck) {
                // Opponent has the puck: Defensive states
                 const isPuckNearOwnGoal = puckDistToOwnGoal < FIELD_WIDTH * 0.3;
                 if (isPuckNearOwnGoal) desiredState = 'DefendGoal';
                 else if (player.role.includes('Back')) desiredState = 'Intercept';
                 else desiredState = 'Pressure';

            } else if (teammateHasPuck) {
                // Teammate has the puck: Support state
                desiredState = 'SupportPuckCarrier';

            } else { // Puck is Loose
                // Puck is loose: Chase or Position states
                 const isPuckNearOwnGoal = puckDistToOwnGoal < FIELD_WIDTH * 0.3;
                 if (isPuckNearOwnGoal) {
                     desiredState = 'ChaseLooseDef';
                 } else {
                     const formationPos = calculateFormationPosition(player, false);
                     const distToFormation = distance(player.x, player.y, formationPos.x, formationPos.y);
                     let chaseThreshold = FIELD_WIDTH * 0.35;
                     if (player.role.includes('Forward')) chaseThreshold = FIELD_WIDTH * 0.5;
                     // Chase if puck is close OR closer than formation spot
                     if (puckDist < chaseThreshold || puckDist < distToFormation * 0.8) {
                          desiredState = 'ChaseLooseOff';
                     } else {
                          desiredState = 'Positioning';
                     }
                 }
            }

            // --- Stamina/Breath overrides (apply AFTER main state decision) ---
             if (player.stamina < 20 && !['Shooting', 'Clearing', 'DefendGoal', 'Surfacing'].includes(desiredState)) {
                 desiredState = 'Positioning'; // Fall back to positioning if tired (unless critical action/surfacing)
             }
             // Low breath override (handled in updatePlayers, but ensure state reflects surfacing)
             if (player.state === 'Surfacing') {
                  desiredState = 'Surfacing'; // Ensure surfacing state persists if set by updatePlayers
             }


            // --- Final State Assignment ---
            // Only log if state changes
            if (player.state !== desiredState) {
                 // console.log(`${player.color} ${player.role} changing state from ${player.state} to ${desiredState}`);
                 player.state = desiredState;
            }


            // --- Set Target and Angle based on State ---
            let targetPos = { x: player.x, y: player.y };

            switch (player.state) {
                case 'Curling': // Advance puck towards opponent goal, avoid opponents
                    targetPos = calculateTargetAdvance(player, opponentGoalX, goalY, nearestOpponent);
                    player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    break;
                case 'Shooting': // Flick towards goal center
                    player.angle = Math.atan2(goalY - player.y, opponentGoalX - player.x);
                    targetPos = { x: player.x, y: player.y }; // Stop moving to shoot
                    // Flick action is handled in handlePlayerPuckInteraction based on state
                    break;
                case 'Clearing': // Move/flick towards side wall
                    const clearTargetY = player.y < FIELD_HEIGHT / 2 ? 0 : FIELD_HEIGHT; // Aim for nearest wall
                    // Angle towards side wall, slightly away from own goal X
                    const angleToSide = Math.atan2(clearTargetY - player.y, (player.x - ownGoalX)); // Point away from own goal X-axis
                    player.angle = angleToSide;
                    targetPos = calculateTargetAdvance(player, player.x + Math.cos(player.angle)*50, clearTargetY, nearestOpponent); // Move towards wall, avoid opp
                    break;
                case 'DefendGoal': // Aggressively move towards puck carrier near own goal
                    if (puckCarrierOpponent) {
                        targetPos = { x: puckCarrierOpponent.x, y: puckCarrierOpponent.y };
                        player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    } else { // Fallback if carrier lost
                        targetPos = { x: puck.x, y: puck.y };
                        player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    }
                    break;
                case 'Intercept': // Backs: Position between puck carrier and own goal
                     if (puckCarrierOpponent) {
                         targetPos = calculateInterceptPosition(player, puckCarrierOpponent, ownGoalX, goalY);
                         player.angle = Math.atan2(puck.y - player.y, puck.x - player.x); // Face puck
                     } else { // Fallback
                         targetPos = calculateFormationPosition(player, false);
                         player.angle = Math.atan2(puck.y - player.y, puck.x - player.x);
                     }
                    break;
                case 'Pressure': // Forwards/Mids: Move towards puck carrier
                    if (puckCarrierOpponent) {
                        targetPos = { x: puckCarrierOpponent.x, y: puckCarrierOpponent.y };
                        player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    } else { // Fallback
                        targetPos = { x: puck.x, y: puck.y };
                        player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    }
                    break;
                case 'ChaseLooseDef':
                case 'ChaseLooseOff':
                    // Directly target the loose puck
                    targetPos = { x: puck.x, y: puck.y };
                    player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    break;

                // *** NEW STATE LOGIC ***
                case 'SupportPuckCarrier':
                    // *** Add internal check: If designated carrier lost puck, reposition ***
                    if (!puckCarrierTeammate || !puckCarrierTeammate.hasPuck) {
                         player.state = 'Positioning'; // Revert state immediately
                         targetPos = calculateFormationPosition(player, false);
                         player.angle = Math.atan2(puck.y - player.y, puck.x - player.y);
                    } else {
                        // Aim for a spot ahead and to the side of the carrier
                        const carrierAngle = puckCarrierTeammate.angle; // Use carrier's direction
                        const supportDist = PLAYER_RADIUS * 6; // How far away to position
                        // Determine side based on player role (Left/Right) or available space
                        const sideOffsetAngle = player.role.includes('Left') ? -Math.PI / 4 : Math.PI / 4; // +/- 45 degrees
                        const supportAngle = carrierAngle + sideOffsetAngle;

                        targetPos.x = puckCarrierTeammate.x + Math.cos(supportAngle) * supportDist;
                        targetPos.y = puckCarrierTeammate.y + Math.sin(supportAngle) * supportDist;

                        // Avoid getting too close to opponents while supporting
                        if (nearestOpponent && distance(targetPos.x, targetPos.y, nearestOpponent.x, nearestOpponent.y) < PLAYER_RADIUS * 4) {
                            // If proposed spot is too close to opponent, try the other side or just hold position
                            const alternateSupportAngle = carrierAngle - sideOffsetAngle;
                            const alternateTargetX = puckCarrierTeammate.x + Math.cos(alternateSupportAngle) * supportDist;
                            const alternateTargetY = puckCarrierTeammate.y + Math.sin(alternateSupportAngle) * supportDist;
                            // Check if alternate spot is safer
                            if (nearestOpponent && distance(alternateTargetX, alternateTargetY, nearestOpponent.x, nearestOpponent.y) >= PLAYER_RADIUS * 4) {
                                targetPos.x = alternateTargetX;
                                targetPos.y = alternateTargetY;
                            } else {
                                // If both sides are risky, maybe just move parallel to carrier or hold?
                                // Simple fallback: move slightly away from carrier
                                targetPos.x = player.x - (puckCarrierTeammate.x - player.x) * 0.1;
                                targetPos.y = player.y - (puckCarrierTeammate.y - player.y) * 0.1;
                            }
                        }

                        // Angle towards the calculated support position
                        player.angle = Math.atan2(targetPos.y - player.y, targetPos.x - player.x);
                    }
                    break;

                case 'Positioning':
                default:
                    targetPos = calculateFormationPosition(player, false);
                    player.angle = Math.atan2(puck.y - player.y, puck.x - player.y); // Orient towards puck
                    break;
            }

            // Clamp target position to field boundaries
            player.targetX = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, targetPos.x));
            player.targetY = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, targetPos.y));
        }

        // --- Helper Functions for AI ---

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }

        function findNearestOpponent(player) {
            const opponents = player.color === 'black' ? teams.white : teams.black;
            let nearestOpp = null;
            let minDistSq = Infinity;

            opponents.forEach(opp => {
                if (!opp.isOnSurface) { // Only consider underwater opponents
                    const dSq = Math.pow(player.x - opp.x, 2) + Math.pow(player.y - opp.y, 2);
                    if (dSq < minDistSq) {
                        minDistSq = dSq;
                        nearestOpp = opp;
                    }
                }
            });
            return nearestOpp;
        }

        function calculateFormationPosition(player, isOnSurface) {
            let targetX, targetY;

            // Parse role
            const roleParts = player.role.split(' ');
            if (roleParts.length !== 2) {
                console.warn(`Invalid role format for formation: ${player.role}`);
                return { x: player.x, y: player.y }; // Fallback: stay put
            }
            const side = roleParts[0]; // "Left" or "Right"
            const baseRole = roleParts[1]; // "Forward", "Mid", "Back"

            // --- Determine Target X using Dynamic Line ---
            const possessingTeam = getPuckPossessorTeam();
            targetX = calculateDynamicLineXForPositioning(baseRole, player.color); // Vertical line (F/M/B)

            // --- Determine Target Y using Left/Right Lines ---
            const puckOnLeft = puck.x < FIELD_WIDTH / 2; // Determine if puck is on the left side
            const leftLineX = puckOnLeft ? puck.x : puck.x - FORMATION_LINE_SPACING;
            const rightLineX = leftLineX + FORMATION_LINE_SPACING;

            targetY = side === 'Left' ? leftLineX : rightLineX;

            // --- Adjustments ---
            // Teammate Avoidance (keep simple vertical push)
            const counterpartRole = (side === 'Left' ? 'Right ' : 'Left ') + baseRole;
            const counterpart = teams[player.color].find(p => p.role === counterpartRole);
            if (counterpart) {
                const dy = player.y - counterpart.y;
                const verticalDist = Math.abs(dy);
                const desiredVerticalDist = FIELD_HEIGHT / 6; // Increase desired separation
                if (verticalDist < desiredVerticalDist && verticalDist > 1) {
                    targetY += Math.sign(dy) * (desiredVerticalDist - verticalDist) * 0.2; // Stronger push
                }
            }

            // Surface positioning adjustment (pull back slightly from line)
            if (isOnSurface) {
                targetX -= (player.color === 'black' ? 1 : -1) * FORMATION_LINE_SPACING * 0.3;
            }

            // Clamp final position
            targetX = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, targetX));
            targetY = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, targetY));

            return { x: targetX, y: targetY };
        }

        // New helper specifically for positioning (handles null possessingTeam)
        function calculateDynamicLineXForPositioning(baseRole, teamColor) {
            const centerBias = (puck.x - FIELD_WIDTH / 2) * PUCK_INFLUENCE_ON_LINES;
            const dynamicCenter = FIELD_WIDTH / 2 + centerBias;
            let lineX;
            const spacing = FORMATION_LINE_SPACING;

            if (teamColor === 'black') { // Attacking right
                if (baseRole === 'Forward') lineX = dynamicCenter + spacing;
                else if (baseRole === 'Back') lineX = dynamicCenter - spacing;
                else lineX = dynamicCenter;
            } else { // White, attacking left
                if (baseRole === 'Forward') lineX = dynamicCenter - spacing;
                else if (baseRole === 'Back') lineX = dynamicCenter + spacing;
                else lineX = dynamicCenter;
            }

            // Clamp line position to field boundaries
            const buffer = PLAYER_RADIUS * 3;
            return Math.max(buffer, Math.min(FIELD_WIDTH - buffer, lineX));
        }

        function handleSurfaceAI(player) {
            // Heuristic: Recover breath, move slowly to formation position, check dive conditions
            if (player.state !== 'SurfaceMove') {
                player.state = 'SurfaceMove'; // Ensure state is correct
            }

            const formationPos = calculateFormationPosition(player, true); // isSurface=true
            player.targetX = formationPos.x;
            player.targetY = formationPos.y;
            player.angle = Math.atan2(player.targetY - player.y, player.targetX - player.x);

            // Check dive conditions (only if breath is full)
            if (player.breath >= player.maxBreath) {
                const diveDecision = shouldDive(player); // Call shouldDive here
                if (diveDecision) {
                    player.isOnSurface = false;
                    player.state = 'ChaseLooseOff'; // Example starting state after dive
                    player.targetX = puck.x;
                    player.targetY = puck.y;
                    console.log(`${player.color} ${player.role} diving! Target Puck.`);
                }
            }
        }

function calculateTargetAdvance(player, targetX, targetY, nearestOpponent) {
    const avoidRadius = PLAYER_RADIUS * 3; // Distance to avoid opponents
    let adjustedX = targetX;
    let adjustedY = targetY;

    if (nearestOpponent) {
        const dx = targetX - nearestOpponent.x;
        const dy = targetY - nearestOpponent.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < avoidRadius) {
            // Adjust target to avoid opponent
            const avoidFactor = (avoidRadius - dist) / avoidRadius;
            adjustedX += dx * avoidFactor;
            adjustedY += dy * avoidFactor;
        }
    }

    // Clamp adjusted position to field boundaries
    adjustedX = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, adjustedX));
    adjustedY = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, adjustedY));

    return { x: adjustedX, y: adjustedY };
}

function findNearestOpponent(player) {
    const opponents = player.color === 'black' ? teams.white : teams.black;
    let nearestOpp = null;
    let minDistSq = Infinity;

    opponents.forEach(opp => {
        if (!opp.isOnSurface) { // Only consider underwater opponents
            const dSq = Math.pow(player.x - opp.x, 2) + Math.pow(player.y - opp.y, 2);
            if (dSq < minDistSq) {
                minDistSq = dSq;
                nearestOpp = opp;
            }
        }
    });
    return nearestOpp;
}

function distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

function getPuckPossessorTeam() {
    for (const player of teams.black) {
        if (player.hasPuck) return 'black';
    }
    for (const player of teams.white) {
        if (player.hasPuck) return 'white';
    }
    return null; // Puck is loose
}

function resetPositionsForKickoff() {
    resetPuck();
    teams.black.forEach(p => {
        p.angle = 0;
        p.state = 'PreKickoff';
        p.isOnSurface = true;
        p.breath = p.maxBreath;
        p.stamina = STAMINA_MAX;
        p.targetX = p.x;
        p.targetY = p.y;
    });
    teams.white.forEach(p => {
        p.angle = Math.PI;
        p.state = 'PreKickoff';
        p.isOnSurface = true;
        p.breath = p.maxBreath;
        p.stamina = STAMINA_MAX;
        p.targetX = p.x;
        p.targetY = p.y;
    });
    gamePaused = false;
    gameState = 'Kickoff';
    console.log("Kickoff!");
}
function calculateDynamicLineXForPositioning(baseRole, teamColor) {
    const centerBias = (puck.x - FIELD_WIDTH / 2) * PUCK_INFLUENCE_ON_LINES;
    const dynamicCenter = FIELD_WIDTH / 2 + centerBias;
    let lineX;
    const spacing = FORMATION_LINE_SPACING;

    if (teamColor === 'black') { // Attacking right
        if (baseRole === 'Forward') lineX = dynamicCenter + spacing;
        else if (baseRole === 'Back') lineX = dynamicCenter - spacing;
        else lineX = dynamicCenter;
    } else { // White, attacking left
        if (baseRole === 'Forward') lineX = dynamicCenter - spacing;
        else if (baseRole === 'Back') lineX = dynamicCenter + spacing;
        else lineX = dynamicCenter;
    }

    // Clamp line position to field boundaries
    const buffer = PLAYER_RADIUS * 3;
    return Math.max(buffer, Math.min(FIELD_WIDTH - buffer, lineX));
}
function calculateInterceptPosition(player, puckCarrier, ownGoalX, goalY) {
    const interceptX = (puckCarrier.x + ownGoalX) / 2; // Midpoint between carrier and goal
    const interceptY = (puckCarrier.y + goalY) / 2; // Midpoint between carrier and goal center

    // Clamp intercept position to field boundaries
    const clampedX = Math.max(PLAYER_RADIUS, Math.min(FIELD_WIDTH - PLAYER_RADIUS, interceptX));
    const clampedY = Math.max(PLAYER_RADIUS, Math.min(FIELD_HEIGHT - PLAYER_RADIUS, interceptY));

    return { x: clampedX, y: clampedY };
}
    // --- Helper Functions for AI ---
    function shouldDive(player) {
        if (player.breath < player.maxBreath) return false; // Can't dive if not recovered

        // --- Strict Cycling Logic ---
        const roleParts = player.role.split(' ');
        if (roleParts.length === 2) { // Check if it's a Left/Right role
            const side = roleParts[0];
            const baseRole = roleParts[1];
            const counterpartRole = (side === 'Left' ? 'Right ' : 'Left ') + baseRole;
            const counterpart = teams[player.color].find(p => p.role === counterpartRole);

            if (counterpart) {
                const counterpartIsUnderwater = !counterpart.isOnSurface && counterpart.state !== 'Surfacing';
                if (counterpartIsUnderwater) {
                    console.log(`${player.role} NOT diving because ${counterpart.role} is underwater.`);
                    return false;
                }
            }
        }

        // Secondary check: Limit total underwater players
        const teammatesUnderwater = teams[player.color].filter(p => p !== player && !p.isOnSurface && p.state !== 'Surfacing').length;
        const maxUnderwaterAllowed = 3; // Limit underwater players
        if (teammatesUnderwater >= maxUnderwaterAllowed) {
            console.log(`${player.role} NOT diving because ${teammatesUnderwater} teammates are already underwater.`);
            return false;
        }

        // Base dive conditions
        const puckDist = distance(player.x, player.y, puck.x, puck.y);
        const randomFactor = Math.random();

        // Dive if puck is close
        if (puckDist < FIELD_WIDTH * 0.25 && randomFactor > 0.4) return true;

        // Small chance to dive proactively
        if (randomFactor > 0.9) {
            console.log(`${player.role} diving proactively.`);
            return true;
        }

        return false; // Default: stay on surface
    }
        // --- Game Logic ---
        function checkGoal() {
            const goalMinY = (FIELD_HEIGHT - GOAL_WIDTH) / 2;
            const goalMaxY = (FIELD_HEIGHT + GOAL_WIDTH) / 2;

            let goalScored = false;
            if (puck.x - PUCK_RADIUS < GOAL_DEPTH && puck.y > goalMinY && puck.y < goalMaxY) {
                scores.white++;
                console.log("Goal for White!");
                goalScored = true;
            } else if (puck.x + PUCK_RADIUS > FIELD_WIDTH - GOAL_DEPTH && puck.y > goalMinY && puck.y < goalMaxY) {
                scores.black++;
                console.log("Goal for Black!");
                goalScored = true;
            }

            if (goalScored) {
                updateUI();
                gamePaused = true; // Pause game updates
                gameState = 'GoalScored';
                setTimeout(resetPositionsForKickoff, 3000); // Pause for 3 secs before next kickoff
            }
        }

        function updateGameTime(timestamp) {
            if (gameState === 'PreKickoff' || gameState === 'GoalScored' || gameState === 'HalfTime' || gameState === 'FullTime') {
                 lastTimestamp = timestamp; // Keep timestamp updated even when paused
                 return 0;
            }

            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            const frameTime = Math.min(deltaTime, 1000 / 15);
            const framesElapsed = frameTime / (1000 / FRAMES_PER_SECOND);

            if (gameState === 'Playing' || gameState === 'Kickoff') { // Only decrement timer during active play/kickoff
                gameTimer -= framesElapsed;
            }

            if (gameTimer <= 0) {
                gameTimer = 0;
                if (currentHalf === 1) {
                    currentHalf = 2;
                    gameTimer = GAME_HALF_TIME_SECONDS * FRAMES_PER_SECOND;
                    console.log("Half Time!");
                    gameState = 'HalfTime';
                    gamePaused = true;
                    setTimeout(resetPositionsForKickoff, 5000); // Longer pause for half time
                } else if (gameState !== 'FullTime') { // Prevent multiple logs
                    console.log("Full Time! Final Score: Black", scores.black, "- White", scores.white);
                    gameState = 'FullTime';
                    gamePaused = true; // End game
                }
            }
            return frameTime;
        }

        function updateUI() {
            // Update Game Info Bar
            const timeRemainingSeconds = Math.max(0, Math.floor(gameTimer / FRAMES_PER_SECOND));
            const minutes = Math.floor(timeRemainingSeconds / 60);
            const seconds = timeRemainingSeconds % 60;
            document.getElementById('gameTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('blackScore').textContent = scores.black;
            document.getElementById('whiteScore').textContent = scores.white;
            document.getElementById('currentHalf').textContent = currentHalf;
            document.getElementById('gameStateDisplay').textContent = gameState; // Update game state display

            // --- Update Player Info Table ---
            const tableBody = document.getElementById('playerInfoTableBody');
            tableBody.innerHTML = ''; // Clear previous entries

            const allPlayers = [...teams.black, ...teams.white];
            allPlayers.sort((a, b) => {
                if (a.color !== b.color) return a.color.localeCompare(b.color);
                return a.role.localeCompare(b.role);
            });

            allPlayers.forEach(player => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = player.color.charAt(0).toUpperCase() + player.color.slice(1);
                row.insertCell().textContent = player.role;
                row.insertCell().textContent = player.state;
                // Add new data columns
                row.insertCell().textContent = player.x.toFixed(1);
                row.insertCell().textContent = player.y.toFixed(1);
                row.insertCell().textContent = player.dx.toFixed(2);
                row.insertCell().textContent = player.dy.toFixed(2);

                // Breath calculation
                const breathCell = row.insertCell();
                if (player.isOnSurface || player.state === 'Surfacing') {
                    const maxSec = (player.maxBreath / FRAMES_PER_SECOND).toFixed(1);
                    breathCell.textContent = `Surf(${maxSec})`;
                    breathCell.style.color = 'lightblue';
                } else {
                    const breathSeconds = (player.breath / FRAMES_PER_SECOND).toFixed(1);
                    breathCell.textContent = breathSeconds;
                    breathCell.style.color = player.breath < player.maxBreath * 0.3 ? 'orange' : 'lightgreen';
                }

                row.insertCell().textContent = player.stamina.toFixed(0); // Stamina
                row.insertCell().textContent = player.targetX.toFixed(1); // Target X
                row.insertCell().textContent = player.targetY.toFixed(1); // Target Y
                row.insertCell().textContent = player.hasPuck ? 'Yes' : 'No'; // Puck?
                row.insertCell().textContent = player.isOnSurface ? 'Yes' : (player.state === 'Surfacing' ? 'Going' : 'No'); // Surface?

            });
            // --- End Update Player Info Table ---
        }

        // --- Main Loop ---
        function gameLoop(timestamp) {
            // Calculate time delta and elapsed frames
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            // Avoid huge jumps if tab was inactive, clamp delta time (e.g., max 1/15th sec)
            const clampedDeltaTime = Math.min(deltaTime, 1000 / 15);
            // Calculate how many simulation frames should have passed based on target FPS
            const framesElapsed = clampedDeltaTime / (1000 / FRAMES_PER_SECOND);

            // Update game timer (uses framesElapsed internally now via updateGameTime logic)
            updateGameTime(timestamp); // timestamp is still needed for timer logic

            if (!gamePaused) {
                updatePuck();
                // *** Pass the calculated framesElapsed to updatePlayers ***
                updatePlayers(framesElapsed);
            }

            // Drawing
            drawField();
            drawPuck();
            drawPlayers();
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        document.getElementById('aiStateToggle').addEventListener('click', () => {
            showAiState = !showAiState;
        });
        // Add resize listener
        window.addEventListener('resize', resizeCanvas);

        // --- Start Game ---
        resizeCanvas(); // Initial sizing
        initPlayers();
        updateUI();
        lastTimestamp = performance.now();
        setTimeout(resetPositionsForKickoff, 1000);
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
