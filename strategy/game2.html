<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UWH - Turn-based Strategy Game</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f0f4f8; margin: 0; }
    #container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      width: 100vw;
      height: 100vh;
      max-width: 100vw; /* Fix: prevent overflow on the right */
      margin: 0;
      box-sizing: border-box;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }
    #left-panel {
      display: flex;
      flex-direction: column;
      min-width: 260px;
      max-width: 320px;
      height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
      background: #fff;
      border-right: 1px solid #ccc;
      z-index: 2;
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      height: 100vh;
      overflow: hidden;
      background: #f0f4f8;
      min-width: 0;
    }
    #right-panel {
      min-width: 260px;
      max-width: 320px;
      height: 100vh;
      overflow-y: auto;
      background: #fff;
      border-left: 1px solid #ccc;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      z-index: 2;
    }
    #scoreboard, #turn, #legend, #tables {
      margin-bottom: 18px;
    }
    #scoreboard { font-size: 1.2em; }
    #turn { margin-bottom: 10px; }
    #legend span { display: inline-block; width: 18px; height: 18px; margin-right: 6px; vertical-align: middle; }
    #next-btn { margin: 18px 0; padding: 10px 20px; font-size: 1em; }
    #hovercard {
      display: none;
      position: absolute;
      background: #fff;
      border: 1px solid #888;
      border-radius: 6px;
      box-shadow: 2px 2px 8px #aaa;
      padding: 12px;
      z-index: 10;
      min-width: 180px;
      font-size: 0.95em;
    }
    canvas { background: #e0e7ef; border: 1px solid #888; }
    #tables { margin-top:10px; display:flex; gap:10px; flex-direction:column; }
    #tables table { border-collapse:collapse; font-size:0.95em; min-width:220px; background:#f8fafd; }
    #tables caption { font-weight:bold; padding:2px 0 4px 0; }
    #tables th, #tables td { padding:2px 6px; text-align:center; }
    #tables tr { border-bottom:1px solid #e0e0e0; }
    #tables tr:first-child th { background:#e3eaf3; }
    #history {
      font-size: 0.97em;
      background: #fffbe7;
      border: 1px solid #e6c200;
      border-radius: 8px;
      box-shadow: 2px 2px 8px #e6c200;
      padding: 8px 12px;
      margin: 10px;
      max-height: 800px;
      overflow-y: auto;
    }
    @media (max-width: 1100px) {
      #container { flex-direction: column; }
      #main { width: 100vw; }
      #left-panel, #right-panel { width: 100vw; max-width: none; height: auto; }
      #tables { flex-direction: row; }
      #history { position: static; width: 100%; max-width: 100vw; }
    }
  </style>
</head>
<body>
<div id="container">
  <div id="left-panel">
    <div id="scoreboard">
      <b>Score</b><br>
      <span style="color:#1976d2">Blue</span>: <span id="score-blue">0</span><br>
      <span style="color:#d32f2f">Red</span>: <span id="score-red">0</span>
    </div>
    <div id="turn">Turn: <span id="turn-num">1</span></div>
    <div id="legend">
      <b>Legend</b><br>
      <span style="background:#1976d2"></span> Blue unit (surface)<br>
      <span style="background:#90caf9"></span> Blue unit (bottom)<br>
      <span style="background:#d32f2f"></span> Red unit (surface)<br>
      <span style="background:#ffcdd2"></span> Red unit (bottom)<br>
      <span style="background:#ffeb3b; border-radius:50%"></span> Puck<br>
      <span style="border-bottom:3px solid #43a047; width:24px; height:0;"></span> Arrow: Move<br>
      <span style="border-bottom:3px solid #fbc02d; width:24px; height:0;"></span> Arrow: Flick<br>
      <span style="border-bottom:3px solid #8e24aa; width:24px; height:0;"></span> Arrow: Rotate<br>
      <span style="border-bottom:3px solid #c62828; width:24px; height:0;"></span> Arrow: Steal<br>
    </div>
    <div id="tables"></div>
  </div>
  <div id="main">
    <canvas id="board" width="1100" height="900"></canvas>
    <div id="hovercard"></div>
    <div id="message" style="position:absolute;left:10px;top:10px;z-index:20;font-size:1.1em;color:#222;background:#fffbe7;border:1px solid #e6c200;padding:8px 18px;border-radius:8px;display:none;box-shadow:2px 2px 8px #e6c200;"></div>
  </div>
  <div id="right-panel">
    <button id="next-btn">Next round</button>
    <div id="history"></div>
  </div>
</div>
<script>
// --- Board parameters ---
const ROWS = 25, COLS = 15;
const HEX_SIZE = 22;
const HEX_H = Math.sqrt(3) * HEX_SIZE;
const BOARD_OFFSET_X = 40, BOARD_OFFSET_Y = 30;

// --- Teams and units ---
const TEAM_BLUE = 'blue';
const TEAM_RED = 'red';
const unitAcronyms = ['LF', 'CF', 'RF', 'LB', 'CB', 'RB'];
const CENTER = { y: 13, x: 8 };

// Mirrored positions for red team (looking up)
const bluePositions = [
  { name: "LB", row: 1, col: 6 },
  { name: "LF", row: 1, col: 7 },
  { name: "CF", row: 1, col: 8 },
  { name: "RF", row: 1, col: 9 },
  { name: "RB", row: 1, col: 10 },
  { name: "CB", row: 1, col: 11 }
];
const redPositions = [
  { name: "LB", row: 25, col: 11 },
  { name: "LF", row: 25, col: 10 },
  { name: "CF", row: 25, col: 8 },
  { name: "RF", row: 25, col: 7 },
  { name: "RB", row: 25, col: 6 },
  { name: "CB", row: 25, col: 5 }
];

function randomStat(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randomProb(min, max) { return Math.round((Math.random() * (max - min) + min) * 10) / 10; }
function randomTurnSpeed() { return [1/3, 2/3, 1][Math.floor(Math.random()*3)]; }

function genUnit(team, idx, row, col, facing) {
  return {
    team, idx, name: unitAcronyms[idx],
    row, col, facing,
    atSurface: true,
    stats: {
      recovery: randomStat(1,5),
      maxHold: randomStat(15,25),
      swim: randomStat(1,3),
      steal: randomProb(0.1,0.8),
      flick: randomStat(1,3),
      turn: randomTurnSpeed()
    },
    breath: undefined,
    planned: { action: 'move', to: {row, col}, dir: facing }
  };
}

function getInitialUnits() {
  const blue = bluePositions.map((p, i) => genUnit('blue', i, p.row, p.col, 3));
  const red = redPositions.map((p, i) => genUnit('red', i, p.row, p.col, 0));
  [...blue, ...red].forEach(u => u.breath = u.stats.maxHold);
  return blue.concat(red);
}

let units = getInitialUnits();
let puck = { row: 13, col: 8, possessedBy: null };
let score = { blue: 0, red: 0 };
let turn = 1;

// --- Board rendering ---
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

function hexToPixel(row, col) {
  const x = BOARD_OFFSET_X + col * HEX_H + (row%2 ? HEX_H/2 : 0);
  const y = BOARD_OFFSET_Y + row * (HEX_SIZE * 1.5);
  return {x, y};
}

function drawHex(x, y, color, fill=true, alpha=0.13) {
  ctx.save();
  ctx.beginPath();
  for(let i=0;i<6;i++) {
    const angle = Math.PI/3 * i - Math.PI/6;
    const px = x + HEX_SIZE * Math.cos(angle);
    const py = y + HEX_SIZE * Math.sin(angle);
    if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.closePath();
  if(fill) {
    ctx.fillStyle = color;
    ctx.globalAlpha = alpha;
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

function drawBoard() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // Draw grid
  for(let r=1;r<=ROWS;r++) for(let c=1;c<=COLS;c++) {
    // Draw goal tiles with correct color
    if (r === 1 && c >= 7 && c <= 9) {
      // Blue goal: solid fill (opaque) and border
      drawHex(...Object.values(hexToPixel(r,c)), '#1976d2', true, 0.55);
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#1976d2';
      ctx.beginPath();
      for(let i=0;i<6;i++) {
        const angle = Math.PI/3 * i - Math.PI/6;
        const px = hexToPixel(r,c).x + HEX_SIZE * Math.cos(angle);
        const py = hexToPixel(r,c).y + HEX_SIZE * Math.sin(angle);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    } else if (r === 25 && c >= 7 && c <= 9) {
      // Red goal: solid fill (opaque) and border
      drawHex(...Object.values(hexToPixel(r,c)), '#d32f2f', true, 0.55);
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#d32f2f';
      ctx.beginPath();
      for(let i=0;i<6;i++) {
        const angle = Math.PI/3 * i - Math.PI/6;
        const px = hexToPixel(r,c).x + HEX_SIZE * Math.cos(angle);
        const py = hexToPixel(r,c).y + HEX_SIZE * Math.sin(angle);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    } else {
      drawHex(...Object.values(hexToPixel(r,c)), '#1976d2');
    }
  }
}

function drawPuck() {
  const {x, y} = hexToPixel(puck.row, puck.col);
  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, 13, 0, 2*Math.PI);
  ctx.fillStyle = '#ffeb3b';
  ctx.shadowColor = '#bfa600';
  ctx.shadowBlur = 8;
  ctx.fill();
  ctx.restore();
}

function drawUnit(unit) {
  const {x, y} = hexToPixel(unit.row, unit.col);
  ctx.save();
  let color, border;
  if(unit.team==='blue') {
    color = unit.atSurface ? '#1976d2' : '#90caf9';
    border = '#0d47a1';
  } else {
    color = unit.atSurface ? '#d32f2f' : '#ffcdd2';
    border = '#b71c1c';
  }
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, 2*Math.PI);
  ctx.fillStyle = color;
  ctx.globalAlpha = unit.atSurface ? 1 : 0.7;
  ctx.shadowColor = unit.atSurface ? '#222' : '#fff';
  ctx.shadowBlur = unit.atSurface ? 8 : 0;
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.lineWidth = 3;
  ctx.strokeStyle = border;
  ctx.stroke();
  // Puck possession indicator
  if(puck.possessedBy === unit) {
    ctx.beginPath();
    ctx.arc(x, y, 26, 0, 2*Math.PI);
    ctx.strokeStyle = '#ffeb3b';
    ctx.lineWidth = 5;
    ctx.globalAlpha = 0.7;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  // Direction triangle
  const angle = Math.PI/3 * unit.facing - Math.PI/2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + 24*Math.cos(angle-0.18), y + 24*Math.sin(angle-0.18));
  ctx.lineTo(x + 24*Math.cos(angle+0.18), y + 24*Math.sin(angle+0.18));
  ctx.closePath();
  ctx.fillStyle = '#fff';
  ctx.globalAlpha = 0.7;
  ctx.fill();
  ctx.globalAlpha = 1;
  // Acronym + breath
  ctx.font = 'bold 13px Arial';
  ctx.fillStyle = '#222';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(unit.name, x, y-2);
  ctx.font = '11px Arial';
  ctx.fillStyle = '#444';
  ctx.fillText(unit.breath, x, y+13);
  ctx.restore();
}

function drawAllUnits() {
  for(const unit of units.filter(u=>u.atSurface)) drawUnit(unit);
  for(const unit of units.filter(u=>!u.atSurface)) drawUnit(unit);
}

function drawPlanned(unit) {
  const {x, y} = hexToPixel(unit.row, unit.col);
  let tx, ty, color;
  if(unit.planned.action==='move') {
    ({x:tx, y:ty} = hexToPixel(unit.planned.to.row, unit.planned.to.col));
    color = '#43a047';
  } else if(unit.planned.action==='flick') {
    ({x:tx, y:ty} = hexToPixel(unit.planned.to.row, unit.planned.to.col));
    color = '#fbc02d';
  } else if(unit.planned.action==='rotate') {
    const angle = Math.PI/3 * unit.planned.dir - Math.PI/2;
    tx = x + 36*Math.cos(angle);
    ty = y + 36*Math.sin(angle);
    color = '#8e24aa';
  } else if(unit.planned.action==='steal') {
    ({x:tx, y:ty} = hexToPixel(unit.planned.to.row, unit.planned.to.col));
    color = '#c62828';
  } else return;
  let dx = tx - x, dy = ty - y;
  let dist = Math.sqrt(dx*dx + dy*dy);
  let startX = x + (dx/dist)*20;
  let startY = y + (dy/dist)*20;
  drawArrow(startX, startY, tx, ty, color);
}

function drawArrow(x1, y1, x2, y2, color) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  const angle = Math.atan2(y2-y1, x2-x1);
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2-12*Math.cos(angle-0.4), y2-12*Math.sin(angle-0.4));
  ctx.lineTo(x2-12*Math.cos(angle+0.4), y2-12*Math.sin(angle+0.4));
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
  ctx.restore();
}

// --- Hovercard ---
canvas.addEventListener('mousemove', function(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  let found = null;
  for(const unit of units) {
    const {x, y} = hexToPixel(unit.row, unit.col);
    if(Math.hypot(mx-x, my-y) < 22) { found = unit; break; }
  }
  const hover = document.getElementById('hovercard');
  if(found) {
    hover.style.display = 'block';
    hover.style.left = (e.clientX+16)+'px';
    hover.style.top = (e.clientY-8)+'px';
    hover.innerHTML = `<b>${found.team==='blue'?'Blue':'Red'} #${found.idx+1} - ${found.name}</b><br>
      <b>Recovery:</b> ${found.stats.recovery}<br>
      <b>Max breath:</b> ${found.stats.maxHold}<br>
      <b>Swim speed:</b> ${found.stats.swim}<br>
      <b>Steal:</b> ${Math.round(found.stats.steal*100)}%<br>
      <b>Flick:</b> ${found.stats.flick}<br>
      <b>Turn speed:</b> ${found.stats.turn}<br>
      <b>State:</b> ${found.atSurface?'Surface':'Bottom'}<br>
      <b>Breath:</b> ${found.breath}`;
  } else {
    hover.style.display = 'none';
  }
});
canvas.addEventListener('mouseleave', ()=>{
  document.getElementById('hovercard').style.display = 'none';
});

// --- Message history ---
let messageHistory = [];
function showMessage(msg) {
  const el = document.getElementById('message');
  el.textContent = msg;
  el.style.display = 'block';
  messageHistory.unshift(msg);
  if(messageHistory.length > 12) messageHistory.length = 12;
  updateHistory();
  if(window.messageTimeout) clearTimeout(window.messageTimeout);
  window.messageTimeout = setTimeout(()=>{el.style.display='none';}, 2200);
}
function updateHistory() {
  const hist = document.getElementById('history');
  if (!messageHistory.length) {
    hist.innerHTML = "<b>History</b><br><i>No events</i>";
  } else {
    hist.innerHTML = "<b>History</b><br>" + messageHistory.map(m=>"<div>"+m+"</div>").join("");
  }
}

// --- Status tables ---
function renderTables() {
  const tables = document.getElementById('tables');
  // Fix: ensure tables are always visible and not hidden by main area
  tables.style.position = "relative";
  tables.style.zIndex = "10";
  tables.style.background = "#fff";
  tables.style.maxWidth = "320px";
  tables.style.overflowX = "auto";
  let puckPos = `<div style="margin-bottom:8px;font-size:1.05em;"><b>Puck</b>: ${puck.row},${puck.col} ${puck.possessedBy ? `(${puck.possessedBy.team==='blue'?'Blue':'Red'} ${puck.possessedBy.name})` : '(free)'}</div>`;
  function makeTable(team) {
    let html = `<table border="1">
      <caption style="color:${team==='blue'?'#1976d2':'#d32f2f'};">${team==='blue'?'Blue':'Red'}</caption>
      <tr><th>Name</th><th>Pos</th><th>State</th><th>Breath</th><th>Puck</th><th>Action</th></tr>`;
    for(const u of units.filter(u=>u.team===team)) {
      let planned = u.planned ? u.planned.action : '';
      let to = u.planned && u.planned.to ? `â†’ ${u.planned.to.row},${u.planned.to.col}` : '';
      html += `<tr>
        <td>${u.name}</td>
        <td>${u.row},${u.col}</td>
        <td>${u.atSurface?'Surface':'Bottom'}</td>
        <td>${u.breath}</td>
        <td>${puck.possessedBy===u?'ðŸŸ¡':''}</td>
        <td>${planned} ${to}</td>
      </tr>`;
    }
    html += '</table>';
    return html;
  }
  tables.innerHTML = puckPos + makeTable('blue') + makeTable('red');
}

function render() {
  drawBoard();
  drawPuck();
  for(const unit of units) drawPlanned(unit);
  drawAllUnits();
  renderTables();
}

// --- Turn logic (AI + rules) ---
document.getElementById('next-btn').onclick = function() {
  // --- AI planning and resolution according to specification ---

  // 1. Plan actions for all units (very simplified AI for demo)
  // - If a unit is underwater and not holding the puck, move toward the puck
  // - If a unit is at surface and breath < max, stay at surface
  // - If a unit is at surface and breath == max, dive
  // - If a unit is holding the puck, move toward opponent goal
  // - If a unit is low on breath and holding the puck, surface

  // For demo: randomize planned moves for all units
  for (const u of units) {
    // If holding puck, move toward goal
    if (puck.possessedBy === u) {
      let targetRow = u.row + (u.team === 'blue' ? 1 : -1);
      u.planned = { action: 'move', to: { row: Math.max(1, Math.min(25, targetRow)), col: u.col }, dir: u.facing };
      continue;
    }
    // If underwater, move toward puck
    if (!u.atSurface) {
      let dr = puck.row > u.row ? 1 : (puck.row < u.row ? -1 : 0);
      let dc = puck.col > u.col ? 1 : (puck.col < u.col ? -1 : 0);
      u.planned = { action: 'move', to: { row: u.row + dr, col: u.col + dc }, dir: u.facing };
      continue;
    }
    // If at surface and breath < max, stay
    if (u.atSurface && u.breath < u.stats.maxHold) {
      u.planned = { action: 'wait', to: { row: u.row, col: u.col }, dir: u.facing };
      continue;
    }
    // If at surface and breath == max, dive
    if (u.atSurface && u.breath >= u.stats.maxHold) {
      u.planned = { action: 'dive', to: { row: u.row, col: u.col }, dir: u.facing };
      continue;
    }
    // Default: wait
    u.planned = { action: 'wait', to: { row: u.row, col: u.col }, dir: u.facing };
  }

  // 2. Resolve moves (no crossing, no stacking on same plane)
  const plannedPositions = {};
  for (const u of units) {
    const key = `${u.planned.to.row},${u.planned.to.col},${u.atSurface}`;
    if (!plannedPositions[key]) {
      plannedPositions[key] = u;
    } else {
      // Conflict: random pick
      if (Math.random() < 0.5) {
        plannedPositions[key] = u;
      }
      // The other stays in place
      u.planned = { action: 'wait', to: { row: u.row, col: u.col }, dir: u.facing };
    }
  }

  // 3. Apply moves and update state
  for (const u of units) {
    if (u.planned.action === 'move') {
      u.row = u.planned.to.row;
      u.col = u.planned.to.col;
    }
    if (u.planned.action === 'dive') {
      u.atSurface = false;
    }
    if (u.planned.action === 'surface') {
      u.atSurface = true;
    }
    // Breath management
    if (u.atSurface) {
      u.breath = Math.min(u.breath + 1, u.stats.maxHold);
    } else {
      u.breath = Math.max(u.breath - 1, 0);
      if (u.breath === 0) u.atSurface = true;
    }
  }

  // 4. Puck pickup and scoring
  let prevPossessor = puck.possessedBy;
  let poss = units.find(u => u.row === puck.row && u.col === puck.col && !u.atSurface);
  if (poss && (!prevPossessor || prevPossessor !== poss)) {
    showMessage(`${poss.team === 'blue' ? 'Blue' : 'Red'} ${poss.name} picks up the puck`);
    puck.possessedBy = poss;
  }
  if (puck.possessedBy && puck.possessedBy.atSurface) {
    showMessage(`${puck.possessedBy.team === 'blue' ? 'Blue' : 'Red'} ${puck.possessedBy.name} surfaces, puck is free`);
    puck.possessedBy = null;
  }
  if (puck.possessedBy) {
    puck.row = puck.possessedBy.row;
    puck.col = puck.possessedBy.col;
  }
  // Goal check
  if (puck.row === 1 && puck.col >= 7 && puck.col <= 9) {
    score.blue++;
    showMessage("Goal for Blue!");
    units = getInitialUnits();
    puck = { row: 13, col: 8, possessedBy: null };
  } else if (puck.row === 25 && puck.col >= 7 && puck.col <= 9) {
    score.red++;
    showMessage("Goal for Red!");
    units = getInitialUnits();
    puck = { row: 13, col: 8, possessedBy: null };
  }

  // 5. Next turn
  turn++;
  document.getElementById('score-blue').textContent = score.blue;
  document.getElementById('score-red').textContent = score.red;
  document.getElementById('turn-num').textContent = turn;
  render();
};

updateHistory();
render();
</script>
</body>
</html>
